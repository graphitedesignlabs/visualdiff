#!/bin/bash

# Check if both PDFs are provided as arguments
if [ "$#" -lt 3 ]; then
    echo "Usage: $0 <input_pdf1> <input_pdf2> <output_pdf> [--debug]"
    exit 1
fi

# Assign input arguments to variables
pdf1=$1
pdf2=$2
output_pdf=$3

# Check if the debug flag is set
debug=false
if [ "$4" == "--debug" ]; then
    debug=true
    echo "Debug mode enabled. Limiting to 30 images."
fi

# Create cache directory if it doesn't exist
mkdir -p cache

# Check if the first greyscale page for PDF1 already exists in the cache
if [ ! -f "cache/pdf1_page_000.png" ]; then
    # Convert PDF1 to greyscale images (one per page) and save to cache
    echo "Converting $pdf1 to greyscale images in cache..."
    convert -density 300 "$pdf1" -colorspace Gray "cache/pdf1_page_%03d.png"
fi

# Check if the first greyscale page for PDF2 already exists in the cache
if [ ! -f "cache/pdf2_page_000.png" ]; then
    # Convert PDF2 to greyscale images (one per page) and save to cache
    echo "Converting $pdf2 to greyscale images in cache..."
    convert -density 300 "$pdf2" -colorspace Gray "cache/pdf2_page_%03d.png"
fi

# Get total page count
page_count=$(ls cache/pdf1_page_*.png | wc -l)

# If in debug mode, limit the number of pages to 30
if [ "$debug" == true ]; then
    page_count=$(($page_count < 30 ? $page_count : 30))
fi

# Generate red and blue images if they don't exist
if [ ! -f "cache/red_page_000.png" ]; then
    echo "Generating red-tinted images for PDF1..."
    convert -size 1x256 gradient:white-red "cache/red_gradient.png"
    for ((i=0; i<$page_count; i++)); do
        img=$(printf "cache/pdf1_page_%03d.png" $i)
        page_num=$(basename "$img" | sed 's/pdf1_page_//' | sed 's/.png//')
        convert "$img" -negate cache/red_gradient.png -clut "cache/red_page_$page_num.png"
    done
fi

if [ ! -f "cache/blue_page_000.png" ]; then
    echo "Generating blue-tinted images for PDF2..."
    convert -size 1x256 gradient:white-blue "cache/blue_gradient.png"
    for ((i=0; i<$page_count; i++)); do
        img=$(printf "cache/pdf2_page_%03d.png" $i)
        page_num=$(basename "$img" | sed 's/pdf2_page_//' | sed 's/.png//')
        convert "$img" -negate cache/blue_gradient.png -clut "cache/blue_page_$page_num.png"
    done
fi

# Create a temp directory to store intermediate images
mkdir -p diff_images

# Loop through all the generated pages and process them
for ((i=0; i<$page_count; i++))
do
    printf "Processing page %d of %d...\n" $((i+1)) $page_count
    grey_page1=$(printf "cache/pdf1_page_%03d.png" $i)
    grey_page2=$(printf "cache/pdf2_page_%03d.png" $i)
    red_page=$(printf "cache/red_page_%03d.png" $i)
    blue_page=$(printf "cache/blue_page_%03d.png" $i)
    diff_page=$(printf "diff_images/diff_page_%03d.png" $i)
    mask_page=$(printf "diff_images/mask_page_%03d.png" $i)
    similar_page=$(printf "diff_images/similar_page_%03d.png" $i)
    blended_page=$(printf "diff_images/blended_page_%03d.png" $i)
    final_page=$(printf "diff_images/final_page_%03d.png" $i)

    # Compute the difference between the two images to find similarities
    convert "$grey_page1" "$grey_page2" -compose Difference -composite "$diff_page"
    
    # Threshold to highlight identical areas
    convert "$diff_page" -threshold 0 -negate "$mask_page"

    # Mask the original image to show only similarities
    convert "$grey_page1" "$mask_page" -compose CopyOpacity -composite "$similar_page"

    # Blend red and blue images at 50%
    convert "$red_page" "$blue_page" -compose Blend -define compose:args=50,50 -composite "$blended_page"

    # Combine the blended red/blue image with the greyscale similarities using Darken
    convert "$blended_page" "$similar_page" -compose Darken -composite "$final_page"
done

# Combine all final images into a single output PDF
echo "Combining final images into $output_pdf in the correct order..."
convert $(ls diff_images/final_page_*.png | sort) "$output_pdf"

# Clean up intermediate images
echo "Cleaning up..."
rm -rf diff_images

echo "Done! The output is saved as $output_pdf."

